"use strict";

function randomNumber(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

function randomFrom(array) {
  return array[Math.floor(Math.random() * array.length)];
}

function shuffle(o) {
  for (var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);

  return o;
}

function addCommas(x) {
  return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

function findInArray(haystack, needle) {
  let n = haystack.indexOf(needle);

  if (n > -1) {
    return n;
  } else {
    return null;
  }
}

function removeFromArray(haystack, needle) {
  for (var i = haystack.length - 1; i--;) {
    if (haystack[i] == needle) {
      haystack.splice(i, 1);
    }
  }
}

function percentOf(total, part) {
  if (total == 0 || part == 0) {
    return 0;
  } else {
    return Math.round(part * 100 / total);
  }
}

function sendEvent(c, a, l, v) {
  if (v) {
    _paq.push(['trackEvent', c, a, l, v]); //ga('send', 'event', { eventCategory: c, eventAction: a, eventLabel: l, eventValue:v });


    console.log('CATEGORY: ' + c + ', ACTION:' + a + ', LABEL:' + l + ', VALUE:' + v);
  } else if (l) {
    _paq.push(['trackEvent', c, a, l]); //ga('send', 'event', { eventCategory: c, eventAction: a, eventLabel: l });


    console.log('CATEGORY: ' + c + ', ACTION:' + a + ', LABEL:' + l);
  } else {
    _paq.push(['trackEvent', c, a]); //ga('send', 'event', { eventCategory: c, eventAction: a });


    console.log('CATEGORY: ' + c + ', ACTION:' + a);
  }
}

const allDecks = [//////////////////////////////////////////
// SCIENCE
{
  name: "Science “Facts”",
  description: "There's a lot of weird but interesting facts in science that actually turn out to be true! This deck contains none of them.",
  cards: ["Honey bees can {speak Korean.}", "Eating a carrot a day will {eventually turn your skin orange.}", "If a rabbit {hears a D# note,} it will immediately attack any other rabbit it sees.", "3 days after milk spoils, it will {smell like lilac.}", "The moon and sun are the {same thing. At night the sun simply cools down.}", "{Dogs} are the most venomous animal in the world.", "Salt in your eyes will {improve your vision.}", "A cat's vertically-split pupils allow it {to see ghosts, but only the ghosts of} other cats.", "Rain is caused by a {blue cloud and a red cloud having} an argument", "{Pouring sugar on} a turtle will cause its shell to melt.", "Sweat is created by {small aphid-like creatues} that live inside your pores.", "Zebras are created when {a white horse and a black horse} have sex.", "The human need to sneeze is just {a desperate cry for attention.}", "PCP was originally used as a {water substitute for American soldiers} in World War I.", "If we don't make changes now{, E will equal mc^3} within 10 years.", "{Cocaine} improves heart function when taken in moderation.", "{Gangrene} will heal naturally if given enough time.", "{The iPhone} was the key piece of technology that allowed humans to finally travel to the moon.", "Some Jewish males are born {without foreskins.}", "Bear attacks can be prevented with {belly rubs.}", "Exposure to {the vacuum of space} will change your sexual orientation.", "Microchips run 1.75 times faster when covered in {milk.}", "{Gravity} is a constant everywhere on Earth, except Mexico.", "The pattern known as “plaid” {doesn't actually exist.}", "{Flashlights} produce small nuclear explosions.", "{There genuinely are} monsters under children's beds.", "{Snow} is a side effect of nuclear fallout.", "Dogs are {only colorblind when they are} not barking.", "Mercury is the only planet that {gets depressed.}", "The human body is made up of 60% {cheap vodka.}", "{Dark matter} killed the dinosaurs.", "Reiki is 100% effective, but energy fields {are disrupted by asking for evidence.}", "The best cure for hiccups is to {stare directly into the sun.}", "The human liver in an organ that turns toxins into {bitcoin.}"]
}, //////////////////////////////////////////
// F PLUS 
{
  name: "F Plus Deck",
  description: "Actual statements from actual people covered on The F Plus Podcast. These can be dirty sometimes, fyi.",
  cards: ["We don't know how to make fat people {into thin people or how to make thin people into fat people.}", "{Slavery} did not exist in America.", "The car has never changed {since the invention of the automobile.}", "I am fully capable of going backwards {and forwards in time and at will.}", "Most people are not {intellectual enough to understand} Family Guy.", "{There is no such thing as a “best”} when it comes to sports or sports teams.", "As of 2002, {love went extinct.}", "{Being a juggalo} is just like being a normal person.", "{Warhammer 40,000} can make anything awesome.", "{Man used to live} for hundreds of years disease free.", "The first polio vaccine, the Salk vaccine{, was a total disaster}.", "There is no difference between night dreams and daytime dreams {except about elephant.}", "{Dolphins} know how to access multiple dimensions.", "{It is legal to} post nude photos of someone without their consent.", "Laura Ingalls Wilder is {God.}", "{The Kardashians} are in league with Al-Qaeda.", "Light creates {gravity.}", "{Canoe} complications are enough to strain any relationship.", "{A toilet} is becoming a completely foreign object to women.", "The Latino people have never had {a revolution.}", "No one on Earth is {gay.}", "Ice is the {natural enemy of} bottled water.", "We're all {goth} now.", "{Leonardo DiCaprio's salary} is bankrupting America.", "{Pubic lice are a turn on because} when you go down on someone, they're like right in your nose.", "Clowns are {sexy.}", "{Dried pee} smells a lot like perfume.", "There's nothing perverted about {sniffing a pretty girl's seat cushion.}", "Minors find it difficult to {masturbate.}", "The inner penis {is before} the outer penis of course.", "It's natural for a person to be sexually {attracted to Pokemon.}", "I was having sex with my ladyfriend {and we're both prego.}", "Women were {made to be} spanked by men.", "Jelqing (manually wringing blood into your penis) {is positively REQUIRED just prior to sex.}", "Sticking a penis in anyone's mouth, man or woman{, has never been conducive to the benefit of anyone.}", "{Ghosts can haunt your anus and} give you mad uncontrollable bouts of farting.", "You can't {write porn} as a virgin.", "Everyone has a {tickling} fetish.", "There is no rational argument for not being a {brony.}", "It's almost impossible to quit {giving yourself wedgies.}", "America should put all its prisoners {into one giant super prison.}", "{Small breasts} are a thing of the past.", "You can improve your sex power by {eating garlic.}"]
}, //////////////////////////////////////////
// CELEBS
{
  name: "Celebrity Lies",
  description: "NONE OF THESE ARE TRUE. There, now we can't get sued for what it says on these cards.",
  cards: ["Nancy Reagan kept a {handgun} in her hair.", "{Justin Bieber} has an IQ of 186.", "Damon Wayans Jr. is actually {Damon Wayans Sr. with a wig on.}", "Shaquille O'Neal has {memorized pi to 256 places.}", "Michael Bay {directed Boyhood, but gave credit to} Richard Linklater.", "Britney Spears {invented tubthumping.}", "David Beckham credits {wiccan magick} as the reason for his success in football.", "The Mercury Thermometer was {invented by Freddy Mercury.}", "{The first couple Matchbox 20} albums are actually really good.", "{Stevie Knicks} has never taken drugs.", "“Goop” is the word that Gwyneth Paltrow uses for {semen.}", "Kanye West doesn't get {the credit he deserves.}", "Guy Fieri has 3 {Michelin stars.}", "Paul Wall and Chamillionaire met {at Seminary.}", "{Bruce Lee} was black.", "Toby Keith converted {to Islam in 2013.}", "Beyoncé has an {alpaca ranch in the Himalayas.}", "The one thing Kurt Vonnegut truly hated was {potatoes.}", "Jenny McCarthy meant to say that {vacuums cause autism.}", "Iggy Azalea and Azalea Banks {are the same person.}", "After leaving Apple, Steve Wozniak got a job as {a hedge fund manager.}", "Benedict Cumberbatch was born and raised in {Tuscaloosa, Alabama.}", "Marvin Gaye's Let's Get It On is actually about {fistfights.}", "An accident at a seance caused Jon Stewart{'s soul to inhabit Trevor Noah's body.}", "The most common request to a barber is {make me look like Kevin Spacey.}", "Owen Wilson's nose is {a prosthetic.}", "Seth Rogan's penis looks like {Jonah Hill.}", "Scarlett Johansson's real full name is {Bubba Dumptruck McGillicuddy, III.}", "{Christopher Walken} is the most successful black actor in Hollywood.", "Chris Pratt's feet {smell of fresh pine needles year round.}", "Thomas Jefferson said the tree of liberty must be watered with {Mountain Dew Code Red.}", "Ru Paul is just {Ron Paul} with a dress on.", "N.W.A.'s “F*** Tha Police” is about {Ice Cube's hatred for Sting.}"]
}, //////////////////////////////////////////
// RANDOM
{
  name: "Miscellaneous",
  description: "Let me be honest with you, all of the cards in this deck are just the cards that didn't fit in any other deck.",
  cards: ["Froot Loops are spelled that way because the cereal contains {blood.}", "Spaghetti and Meatballs is known as {Pasketti and Meatbulbs} in Italy.", "{A barn owl} is the only animal on earth that can feel love.", "No one understands how {drums} work.", "The best selling death metal album of all time is {Babel by Mumford & Sons.}", "The keys to Steinway pianos are made from {human finger bones.}", "The constitution {must be fed with 20ml of honey per day} or it starts to create amendments.", "The best way to get white wine out of a shirt is {with red wine.}", "People who wear glasses {are all liars.}", "{Everyone playing this game with you} is a lizard person.", "{Sand dollars} are valid US currency.", "IBM's Deep Blue supercomputer is trying to figure out {how many Fast & Furious movies there are.}", "{The Wrongest Words} is a government test for autism.", "{Salt} needs more sugar.", "{Zombies} caused the end of the Roman Empire.", "Jesus was pretty explicit about not {baking cakes for} gay people."]
}, //////////////////////////////////////////
// RANDOM
{
  name: "EVERYTHING!",
  description: "I don't wanna choose! Just shuffle in all the cards and let's see what happens..."
}];
"use strict";

const settings = {
  timeToPresent: 30
};
const audioSrc = '/audio/'; /////////////////////////////////
// Interface Sounds

const soundBeginTalking = new Howl({
  src: [audioSrc + 'time-is-now-585.mp3', audioSrc + 'time-is-now-585.ogg'],
  volume: 0.9
});
const soundPresentationOver = new Howl({
  src: [audioSrc + 'decay-475.mp3', audioSrc + 'decay-475.ogg'],
  volume: 0.9
});

function resetRoundVariables() {
  app.round.phase = "presenting";
  app.round.activePlayerIndex = -1;
  app.round.dealerIndex = 0;
  app.round.playerPresenting = false;
  app.round.presentationTimer = undefined;
  app.round.presentationTimeLeft = settings.timeToPresent;
  app.round.cardsPresented = [];
  app.round.votesSubmitted = 0;
}

function resetUIVariables() {
  app.ui.upVoteIndex = -1;
  app.ui.downVoteIndex = -1;
  app.ui.iVoted = false;
}

function changeFavicon(src) {
  var link = document.createElement('link'),
      oldLink = document.getElementById('dynamic-favicon');
  link.id = 'dynamic-favicon';
  link.rel = 'shortcut icon';
  link.href = src;

  if (oldLink) {
    document.head.removeChild(oldLink);
  }

  document.head.appendChild(link);
}

Vue.directive('focus', {
  // When the bound element is inserted into the DOM...
  inserted: function (el) {
    // Focus the element
    el.focus();
  }
});
var app = new Vue({
  el: '#app',
  data: {
    roomCode: "",
    gameName: "wrongest",
    isRoomHost: false,
    inRoom: false,
    gameStarted: false,
    gameOver: false,
    maxRounds: 0,
    allDecks: allDecks,
    chosenDeck: {},
    my: {
      name: "",
      socketID: "",
      card: "",
      playerIndex: -1
    },
    gameDeck: {},
    players: [],
    cardsPlayed: [],
    round: {
      phase: "",
      number: 0,
      dealerIndex: -1,
      activePlayerIndex: -1,
      playerPresenting: false,
      presentationTimer: undefined,
      presentationTimeLeft: settings.timeToPresent,
      cardsPresented: [],
      votesSubmitted: 0
    },
    ui: {
      watchingVideo: false,
      nameEntered: false,
      deckName: "",
      upVoteIndex: -1,
      downVoteIndex: -1,
      iVoted: false
    },
    statementHistory: [],
    voteHistory: []
  },
  methods: {
    ////////////////////
    // Room Create, Room Join
    createRoom() {
      const self = this;

      function makeID(digits) {
        let text = "";
        const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        for (let i = 0; i < digits; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));

        return text;
      }

      self.roomCode = makeID(4); // Create a room with the randomly generated code.

      socket.emit('createRoom', {
        roomCode: self.roomCode,
        gameName: self.gameName
      }); // Set your local variables.

      self.isRoomHost = true;
      self.inRoom = true;
      let url = new URL(location.protocol + '//' + location.host + location.pathname);
      url.searchParams.set('room', self.roomCode);
      window.history.pushState({}, '', url);
    },

    joinRoom() {
      const self = this; // Try to join a room with the entered code.

      socket.emit('joinRoom', {
        roomCode: self.roomCode,
        gameName: self.gameName
      });
      socket.emit('requestPlayers', self.roomCode);
      self.isRoomHost = false;
      self.inRoom = true;
      let url = new URL(location.protocol + '//' + location.host + location.pathname);
      url.searchParams.set('room', self.roomCode);
      window.history.pushState({}, '', url);
    },

    watchVideo() {
      const self = this;
      self.ui.watchingVideo = true;

      if (self.inRoom) {
        sendEvent("The Wrongest Words", "Instruction Video", "Pregame Screen");
      } else {
        sendEvent("The Wrongest Words", "Instruction Video", "Title Screen");
      }
    },

    ////////////////////////////////////////
    // Pregame
    updateMyInfo() {
      const self = this;
      const p = {
        name: self.my.name,
        socketID: self.my.socketID,
        card: "",
        score: 0
      }; // Put this player in the Player Array.

      if (!self.ui.nameEntered) {
        self.players.push(p);
      } else {
        self.my.playerIndex = -1;
        self.players.forEach(function (player, index) {
          if (player.socketID == self.my.socketID) {
            //alert('found one');
            self.players[index].name = self.my.name;
          }
        });
      } // find this player's playerIndex


      self.players.forEach(function (player, index) {
        if (player.socketID == self.my.socketID) {
          self.my.playerIndex = index;
        }
      });
      self.ui.nameEntered = true;
      self.sendPlayerUpdate();

      if (self.my.playerIndex < 0) {
        alert('WARNING: I have a player index of ' + self.my.playerIndex + '! This should not happen. I am a bug.');
      }

      _paq.push(['setUserId', self.my.name]);
    },

    sendPlayerUpdate() {
      const self = this;
      socket.emit('updatePlayers', {
        roomCode: self.roomCode,
        players: self.players,
        gameStarted: self.gameStarted,
        roundNumber: self.round.number
      });
    },

    changeDeck() {
      const self = this;

      if (self.ui.deckName == "EVERYTHING!") {
        let cardStack = [];
        self.allDecks.forEach(function (deck) {
          cardStack = cardStack.concat(deck.cards);
        });
        self.chosenDeck = {
          name: "EVERYTHING!",
          description: "I don't wanna choose! Just shuffle in all the cards and let's see what happens...",
          cards: cardStack
        };
      } else {
        let chosenDeck = self.allDecks.filter(deck => deck.name == self.ui.deckName);
        self.chosenDeck = chosenDeck[0];
      }
    },

    startTheGame() {
      const self = this;
      let d = shuffle(self.chosenDeck.cards);
      self.gameDeck.cards = d;
      self.dealOutCards();

      if (self.computedPlayerCount == 3 || self.computedPlayerCount == 4) {
        self.maxRounds = 4;
      } else if (self.computedPlayerCount == 5 || self.computedPlayerCount == 6) {
        self.maxRounds = 3;
      } else if (self.computedPlayerCount > 6) {
        self.maxRounds = 2;
      }

      socket.emit('startTheGame', {
        roomCode: self.roomCode,
        gameName: self.gameName,
        players: self.players,
        gameDeck: self.gameDeck,
        maxRounds: self.maxRounds,
        chosenDeckName: self.chosenDeck.name
      });
      sendEvent("The Wrongest Words", "Game Started", self.roomCode);
    },

    ////////////////////////////////////////
    // In Game
    dealOutCards() {
      const self = this;

      if (self.gameDeck.cards.length <= self.computedPlayerCount) {
        ////////////////////////////////////////////////////////////
        // You've run out of cards. 
        // EMERGENCY BACKUP SCENARIO.
        let newDeck = randomFrom(allDecks);
        let d = shuffle(newDeck.cards);
        self.gameDeck.cards = d;
        let instance = Vue.$toast.open({
          message: "<div style='max-width:32ch; line-height:150%;'><h3 style='font-size:130%; margin-bottom:1em;'>You've run out of cards.</h3>As such, I've chosen a new deck and shuffled that for you.</div>",
          type: "info",
          duration: 50000
        });
      }

      self.players.forEach(function (player, index) {
        self.players[index].card = self.gameDeck.cards[0];
        self.gameDeck.cards.shift();
      });
    },

    sendGameDeck() {
      socket.emit('sendGameDeck', {
        roomCode: self.roomCode,
        gameDeck: self.gameDeck
      });
    },

    dealCard() {
      const self = this;
      self.round.activePlayerIndex++;
      socket.emit('startPresenting', {
        roomCode: self.roomCode,
        activePlayerIndex: self.round.activePlayerIndex,
        activePlayerName: self.players[self.round.activePlayerIndex].name
      });
      soundBeginTalking.play();
    },

    presentationFinished() {
      const self = this;
      app.round.playerPresenting = false;
      app.resetPresentationTimer();
      socket.emit('donePresenting', {
        roomCode: self.roomCode,
        activePlayerIndex: self.round.activePlayerIndex,
        activePlayerName: self.players[self.round.activePlayerIndex].name,
        activePlayerCard: self.players[self.round.activePlayerIndex].card
      });
      soundPresentationOver.play();
    },

    /////////////////////////////////////////
    // Voting
    startVoting() {
      const self = this;
      socket.emit('startVoting', {
        roomCode: self.roomCode,
        cardsPresented: self.round.cardsPresented
      });
    },

    voteUp(index) {
      const self = this;
      self.ui.upVoteIndex = index;

      if (self.ui.downVoteIndex == index) {
        self.ui.downVoteIndex = -1;
      }
    },

    voteDown(index) {
      const self = this;
      self.ui.downVoteIndex = index;

      if (self.ui.upVoteIndex == index) {
        self.ui.upVoteIndex = -1;
      }
    },

    submitVotes() {
      const self = this;
      socket.emit('submitVotes', {
        roomCode: self.roomCode,
        votingPlayerIndex: self.my.playerIndex,
        votingPlayerName: self.my.name,
        downVoteIndex: self.ui.downVoteIndex,
        upVoteIndex: self.ui.upVoteIndex,
        downVoteCard: app.round.cardsPresented[app.ui.downVoteIndex].card,
        upVoteCard: app.round.cardsPresented[app.ui.upVoteIndex].card
      });
      self.ui.iVoted = true;
      sendEvent("The Wrongest Words", "Downvote", app.round.cardsPresented[app.ui.downVoteIndex].card);
      sendEvent("The Wrongest Words", "Upvote", app.round.cardsPresented[app.ui.upVoteIndex].card);
    },

    startNextRound() {
      const self = this;
      self.players.push(self.players.shift());
      self.round.number += 1;
      self.dealOutCards();
      const s = self.statementHistory.concat(self.round.cardsPresented);
      self.statementHistory = s;
      socket.emit('startNextRound', {
        roomCode: self.roomCode,
        gameName: self.gameName,
        players: self.players,
        gameDeck: self.gameDeck,
        statementHistory: self.statementHistory,
        roundNumber: self.round.number
      });
    },

    sendGameOver() {
      const self = this;
      const s = self.statementHistory.concat(self.round.cardsPresented);
      self.statementHistory = s;
      socket.emit('gameOver', {
        roomCode: self.roomCode,
        gameName: self.gameName,
        players: self.players,
        gameDeck: self.gameDeck,
        statementHistory: self.statementHistory,
        roundNumber: self.round.number
      });
    },

    ////////////////////////////////////////
    // Timers
    startPresentationTimer() {
      const self = this;
      self.round.presentationTimeLeft = settings.timeToPresent;
      self.round.presentationTimer = setInterval(() => {
        self.round.presentationTimeLeft -= 0.05;

        if (self.round.presentationTimeLeft <= 0) {
          if (self.computedAmIPresenting) {
            self.presentationFinished();
          }
        }
      }, 50);
    },

    resetPresentationTimer() {
      const self = this;
      clearInterval(self.round.presentationTimer);
      self.round.presentationTimer = undefined;
      self.round.presentationTimeLeft = settings.timeToPresent;
    },

    cardText(txt) {
      const self = this;

      if (self.gameStarted && self.computedAmIPresenting) {
        let t = txt.replace('{', '<span class="secret-text">').replace('}', '</span>');
        return t;
      } else if (self.round.phase == "presenting" && self.round.activePlayerIndex < self.my.playerIndex) {
        return txt.replace(/\{.*?\}/, "...");
      } else {
        return txt.replace('{', '').replace('}', '');
      }
    }

  },
  computed: {
    computedPlayerCount() {
      const self = this;

      if (self.players && self.players.length >= 0) {
        return self.players.length;
      } else {
        return 0;
      }
    },

    computedCanIAdvanceTheGame() {
      const self = this;

      if (self.round.phase == 'presenting') {
        if (self.round.activePlayerIndex + 1 == self.my.playerIndex && !self.round.playerPresenting) {
          // I'm next to play, I see a button.
          return true;
        } else if (self.my.playerIndex == 0 && self.players.length == self.round.activePlayerIndex + 1 && !self.round.playerPresenting) {
          // It's time to vote, and I'm the first player.
          return true;
        } else {
          return false;
        }
      } else if (self.round.phase == 'voting') {
        if (self.my.playerIndex == 0 && self.round.votesSubmitted >= self.computedPlayerCount) {
          return true;
        } else {
          return false;
        }
      }

      return false;
    },

    computedAmIPresenting() {
      const self = this;

      if (self.round.playerPresenting == true && self.round.activePlayerIndex == self.my.playerIndex) {
        return true;
      } else {
        return false;
      }
    },

    computedAreAllVotesCast() {
      const self = this;

      if (self.round.votesSubmitted >= self.computedPlayerCount) {
        return true;
      } else {
        return false;
      }
    },

    computedDashOffset() {
      const self = this;
      let a = percentOf(self.round.presentationTimeLeft, settings.timeToPresent);
      let d = 251 - percentOf(a, 251);
      return d.toFixed(2) + 'px';
    },

    computedPlayersByScore() {
      const self = this;
      const computedPlayers = [...self.players];

      function compare(a, b) {
        if (a.score < b.score) return 1;
        if (a.score > b.score) return -1;
        return 0;
      }

      return computedPlayers.sort(compare);
    },

    computedStatementsByScore() {
      const self = this;
      const computedStatements = [...self.statementHistory];

      function compare(a, b) {
        if (a.score < b.score) return 1;
        if (a.score > b.score) return -1;
        return 0;
      }

      let sortedListAll = computedStatements.sort(compare);
      let leastWrongList = sortedListAll.filter(statement => statement.score >= sortedListAll[0].score);
      let wrongestList = sortedListAll.filter(statement => statement.score <= sortedListAll[sortedListAll.length - 1].score);
      return {
        wrongest: wrongestList,
        leastWrong: leastWrongList,
        all: sortedListAll
      };
    }
    /*
    computedTheWrongestWords() {
      const self = this;
      if (!self.computedStatementsByScore) {
        return null;
      } else {
        const computedStatements = [...self.computedStatementsByScore];
        return computedStatements.filter(statement => statement.score >= computedStatements[0].score);
      }
    }
    */


  },
  mounted: function () {
    const self = this;
    var urlParams = new URLSearchParams(window.location.search);

    if (urlParams.has('create')) {
      self.createRoom();
    } else if (urlParams.has('room')) {
      self.roomCode = urlParams.get('room').toUpperCase();
      self.joinRoom();
    } else if (urlParams.has('join')) {
      document.getElementById("EnterRoomCode").focus();
    } /////////////////////////////////////
    // Fake a Game Over

    /*
    self.inRoom = true;
    self.gameStarted = true;
    self.gameOver = true;
    self.round.phase = "GAME OVER";
    self.players = [{"name":"Four","socketID":"amu153xNcGNFYbrNAAAZ","card":"Clowns are {sexy.}","score":2},{"name":"One","socketID":"H3VJpdzS0oFvU2KnAAAT","card":"Laura Ingalls Wilder is {God.}","score":4},{"name":"Two","socketID":"Q0Jb1qZaIjel8a3iAAAV","card":"Ice is the {natural enemy of} bottled water.","score":-4},{"name":"Three","socketID":"d-BI3QtAXf0XxMTuAAAX","card":"Women were {made to be} spanked by men.","score":-2}];
    self.statementHistory = [{"card":"{Man used to live} for hundreds of years disease free.","playerIndex":0,"playerName":"One","score":0},{"card":"Jelqing (manually wringing blood into your penis) {is positively REQUIRED just prior to sex.}","playerIndex":1,"playerName":"Two","score":0},{"card":"The first polio vaccine, the Salk vaccine{, was a total disaster}.","playerIndex":2,"playerName":"Three","score":-3},{"card":"{It is legal to} post nude photos of someone without their consent.","playerIndex":3,"playerName":"Four","score":3},{"card":"It's almost impossible to quit {giving yourself wedgies.}","playerIndex":0,"playerName":"Two","score":-1},{"card":"The inner penis {is before} the outer penis of course.","playerIndex":1,"playerName":"Three","score":-1},{"card":"There is no difference between night dreams and daytime dreams {except about elephant.}","playerIndex":2,"playerName":"Four","score":1},{"card":"{Leonardo DiCaprio's salary} is bankrupting America.","playerIndex":3,"playerName":"One","score":1},{"card":"The Latino people have never had {a revolution.}","playerIndex":0,"playerName":"Three","score":3},{"card":"I was having sex with my ladyfriend {and we're both prego.}","playerIndex":1,"playerName":"Four","score":-3},{"card":"We don't know how to make fat people {into thin people or how to make thin people into fat people.}","playerIndex":2,"playerName":"One","score":0},{"card":"No one on Earth is {gay.}","playerIndex":3,"playerName":"Two","score":0}];
    */

  }
}); // Inform the player of their own socketID

socket.on("getSocketID", function (msg) {
  console.info("Player socketID is " + msg);
  app.my.socketID = msg;
}); // Someone joined a room.

socket.on("joinRoom", function (msg) {// Don't do anything.
});
socket.on("requestPlayers", function (msg) {
  console.log("The client wants players from me!");

  if (app.isRoomHost) {
    socket.emit("updatePlayers", {
      roomCode: app.roomCode,
      players: app.players,
      gameStarted: app.gameStarted,
      roundNumber: app.round.number
    });
    console.log("I'm the host! I gave the room all the players I know about!");
  }
}); // Someone updated a player (this should have been the game host)

socket.on("updatePlayers", function (msg) {
  console.log("THE PLAYERS HAVE BEEN UPDATED!!!!!!!!");
  app.players = msg.players;
  app.gameStarted = msg.gameStarted;
  app.round.number = msg.roundNumber;
}); // The host has started the game!

socket.on("startTheGame", function (msg) {
  app.players = msg.players;
  app.gameDeck = msg.gameDeck;
  app.chosenDeck.name = msg.chosenDeckName;
  app.maxRounds = msg.maxRounds;
  app.gameStarted = true;
  app.round.number = 1;
  app.round.dealerIndex = 0;
  app.round.phase = "presenting"; // Assign my player index...

  app.players.forEach(function (player, index) {
    if (player.socketID == app.my.socketID) {
      app.my.playerIndex = index;
    }
  }); //Grab my card.

  if (app.my.playerIndex > -1) {
    app.my.card = app.players[app.my.playerIndex].card;
  }

  changeFavicon("wrongest/favicons/favicon.ico");
}); // A player must present now!

socket.on("startPresenting", function (msg) {
  app.round.activePlayerIndex = msg.activePlayerIndex;
  app.round.playerPresenting = true; // UNUSED : activePlayerName

  app.startPresentationTimer();
}); // A player has finished presenting.

socket.on("donePresenting", function (msg) {
  app.round.cardsPresented.push({
    card: msg.activePlayerCard,
    playerIndex: msg.activePlayerIndex,
    playerName: msg.activePlayerName,
    score: 0
  });
  app.round.playerPresenting = false;
  app.resetPresentationTimer();
}); // Voting begins

socket.on("startVoting", function (msg) {
  app.round.cardsPresented = msg.cardsPresented;
  app.round.phase = "voting";
});
socket.on("submitVotes", function (msg) {
  const dI = app.voteHistory.push({
    downVoteIndex: msg.downVoteIndex,
    voterName: msg.votingPlayerName,
    voted: 'down',
    presenter: app.round.cardsPresented[msg.downVoteIndex].playerName,
    card: app.round.cardsPresented[msg.downVoteIndex].card
  });
  app.voteHistory.push({
    upVoteIndex: msg.upVoteIndex,
    voterName: msg.votingPlayerName,
    voted: 'up',
    presenter: app.round.cardsPresented[msg.upVoteIndex].playerName,
    card: app.round.cardsPresented[msg.upVoteIndex].card
  });
  app.players[msg.downVoteIndex].score -= 1;
  app.round.cardsPresented[msg.downVoteIndex].score -= 1;
  app.players[msg.upVoteIndex].score += 1;
  app.round.cardsPresented[msg.upVoteIndex].score += 1;
  app.round.votesSubmitted += 1;

  if (app.round.votesSubmitted >= app.computedPlayerCount) {// This should be handled in the UI.
  }
}); // The host has started the game!

socket.on("startNextRound", function (msg) {
  app.players = msg.players;
  app.gameDeck = msg.gameDeck;
  app.round.number = msg.roundNumber;
  app.statementHistory = msg.statementHistory;
  resetRoundVariables();
  resetUIVariables(); // Assign my player index...

  app.players.forEach(function (player, index) {
    if (player.socketID == app.my.socketID) {
      app.my.playerIndex = index;
    }
  }); //Grab my card.

  if (app.my.playerIndex > -1) {
    app.my.card = app.players[app.my.playerIndex].card;
  }
});
socket.on("gameOver", function (msg) {
  app.players = msg.players;
  app.statementHistory = msg.statementHistory;
  resetRoundVariables();
  resetUIVariables();
  app.round.phase = "GAME OVER";
  app.gameOver = true;

  if (app.isRoomHost) {
    sendEvent("The Wrongest Words", "Game Over", app.roomCode);
  }
});